diff --git a/assets/login/password.txt b/assets/login/password.txt
new file mode 100644
index 0000000..41843e7
--- /dev/null
+++ b/assets/login/password.txt
@@ -0,0 +1,3 @@
+201127
+201127
+201127
diff --git a/assets/login/username.txt b/assets/login/username.txt
new file mode 100644
index 0000000..6c5fb5c
--- /dev/null
+++ b/assets/login/username.txt
@@ -0,0 +1,3 @@
+larry
+david
+larryworm
diff --git a/src/main/java/org/eom/login_control/LoginFrame.java b/src/main/java/org/eom/login_control/LoginFrame.java
index b1266f7..8a3fdde 100644
--- a/src/main/java/org/eom/login_control/LoginFrame.java
+++ b/src/main/java/org/eom/login_control/LoginFrame.java
@@ -1,104 +1,116 @@
 package org.eom.login_control;
 
-import java.awt.Font;
+import org.eom.main.MainControl;
+
+import javax.swing.*;
+import java.awt.*;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
-
-import javax.swing.JButton;
-import javax.swing.JFrame;
-import javax.swing.JLabel;
-import javax.swing.JPasswordField;
-import javax.swing.JTextField;
-
-import org.eom.main.MainControl;
+import java.io.IOException;
 
 public class LoginFrame implements ActionListener {
 
-	private JFrame frame;
-	private JPasswordField passwordField;
-	private JButton login, register;
-	private JTextField usernameField;
-
-	public LoginFrame() {
-		// initialize frame
-		frameInit();
-		
-		// initialize buttons
-		buttonInit();
-
-		// initialize user input fields
-		userInputFieldInit();
-
-		// initialize labels
-		labelInit();
-		
-		frame.setVisible(true);
-
-	}
-
-	public void frameInit() {
-		// initialize frame
-		frame = new JFrame("Login");
-		frame.setLayout(null);
-		frame.setSize(300, 300);
-		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-	}
-
-	public void buttonInit() {
-		// register login button
-		login = new JButton("Login");
-		login.setBounds(115, 158, 85, 25);
-		login.addActionListener(this);
-		frame.add(login);
-
-		// register register button
-		register = new JButton("Register");
-		register.setBounds(115, 196, 85, 25);
-		register.addActionListener(this);
-		frame.add(register);
-	}
-
-	public void userInputFieldInit() {
-		// register password field
-		passwordField = new JPasswordField();
-		passwordField.setBounds(105, 114, 105, 22);
-		frame.add(passwordField);
-
-		// register user name field
-		usernameField = new JTextField();
-		usernameField.setBounds(105, 79, 105, 22);
-		frame.add(usernameField);
-	}
-
-	public void labelInit() {
-		// register user name label
-		JLabel labelUsername = new JLabel("Username");
-		labelUsername.setBounds(35, 82, 76, 16);
-		frame.add(labelUsername);
-
-		// register password label
-		JLabel labelPassword = new JLabel("Password");
-		labelPassword.setBounds(35, 117, 66, 16);
-		frame.add(labelPassword);
-
-		// register label for title
-		Font font = new Font("Arial", Font.BOLD, 26);
-		JLabel labelTitle = new JLabel("TTT Login");
-		labelTitle.setFont(font);
-		labelTitle.setBounds(35, 30, 150, 30);
-		frame.add(labelTitle);
-	}
-
-	@Override
-	public void actionPerformed(ActionEvent event) {
-		if (event.getSource() == login) {
-
-		}
-
-		else if (event.getSource() == register) {
-			MainControl.register();
-		}
-
-	}
-
+    private JFrame frame;
+    private JPasswordField passwordField;
+    private JButton login, register;
+    private JTextField usernameField;
+
+    public LoginFrame() {
+        // initialize frame
+        frameInit();
+
+        // initialize buttons
+        buttonInit();
+
+        // initialize user input fields
+        userInputFieldInit();
+
+        // initialize labels
+        labelInit();
+
+        frame.setVisible(true);
+
+    }
+
+    private void frameInit() {
+        // initialize frame
+        frame = new JFrame("Login");
+        frame.setLayout(null);
+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
+        frame.setSize(300, 300);
+        frame.setLocationRelativeTo(null);
+    }
+
+    private void buttonInit() {
+        // register login button
+        login = new JButton("Login");
+        login.setBounds(115, 158, 85, 25);
+        login.addActionListener(this);
+        frame.add(login);
+
+        // register register button
+        register = new JButton("Register");
+        register.setBounds(115, 196, 85, 25);
+        register.addActionListener(this);
+        frame.add(register);
+    }
+
+    private void userInputFieldInit() {
+        // register password field
+        passwordField = new JPasswordField();
+        passwordField.setBounds(105, 114, 105, 22);
+        frame.add(passwordField);
+
+        // register user name field
+        usernameField = new JTextField();
+        usernameField.setBounds(105, 79, 105, 22);
+        frame.add(usernameField);
+    }
+
+    private void labelInit() {
+        // register user name label
+        JLabel labelUsername = new JLabel("Username");
+        labelUsername.setBounds(35, 82, 76, 16);
+        frame.add(labelUsername);
+
+        // register password label
+        JLabel labelPassword = new JLabel("Password");
+        labelPassword.setBounds(35, 117, 66, 16);
+        frame.add(labelPassword);
+
+        // register label for title
+        Font font = new Font("Arial", Font.BOLD, 26);
+        JLabel labelTitle = new JLabel("TTT Login");
+        labelTitle.setFont(font);
+        labelTitle.setBounds(35, 30, 150, 30);
+        frame.add(labelTitle);
+    }
+
+    @Override
+    public void actionPerformed(ActionEvent event) {
+        if (event.getSource() == login) {
+            loginAction();
+        } else if (event.getSource() == register) {
+            MainControl.register();
+        }
+    }
+
+    private void loginAction() {
+        String inputUsername = usernameField.getText();
+        String inputPassword = new String(passwordField.getPassword());
+        LoginLogic obj = new LoginLogic(inputUsername, inputPassword);
+
+        try {
+            if (obj.login()) {
+                frame.dispose();
+                MainControl.TTTGame();
+            } else {
+                JOptionPane.showMessageDialog(frame, "Incorrect Username or Password");
+                usernameField.setText("");
+                passwordField.setText("");
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/main/java/org/eom/login_control/LoginLogic.java b/src/main/java/org/eom/login_control/LoginLogic.java
new file mode 100644
index 0000000..ee6780e
--- /dev/null
+++ b/src/main/java/org/eom/login_control/LoginLogic.java
@@ -0,0 +1,39 @@
+package org.eom.login_control;
+
+import org.eom.main.FileInput;
+import org.eom.main.MainControl;
+
+import java.io.IOException;
+
+public class LoginLogic {
+
+    private String username, password;
+
+    public LoginLogic(String inputUsername, String inputPassword) {
+        username = inputUsername;
+        password = inputPassword;
+    }
+
+    public boolean login() throws IOException {
+        // initialize variables
+        FileInput usernameFile = new FileInput(MainControl.USERNAME_PATH);
+        FileInput passwordFile = new FileInput(MainControl.PASSWORD_PATH);
+
+        // check for correct passwords
+        String lineName = usernameFile.readLine();
+        String linePassword = passwordFile.readLine();
+        while (lineName != null && linePassword != null) {
+            if (username.equals(lineName) && password.equals(linePassword)) {
+                usernameFile.closeFile();
+                passwordFile.closeFile();
+                return true;
+            } else {
+                lineName = usernameFile.readLine();
+                linePassword = passwordFile.readLine();
+            }
+        }
+
+        return false;
+    }
+
+}
diff --git a/src/main/java/org/eom/login_control/RegisterFrame.java b/src/main/java/org/eom/login_control/RegisterFrame.java
index ed6dfe2..2ec75bd 100644
--- a/src/main/java/org/eom/login_control/RegisterFrame.java
+++ b/src/main/java/org/eom/login_control/RegisterFrame.java
@@ -1,88 +1,132 @@
 package org.eom.login_control;
 
-import java.awt.Font;
+import javax.swing.*;
+import java.awt.*;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
-
-import javax.swing.JButton;
-import javax.swing.JFrame;
-import javax.swing.JLabel;
-import javax.swing.JPasswordField;
-import javax.swing.JTextField;
+import java.io.IOException;
 
 
 public class RegisterFrame implements ActionListener {
 
-	private JFrame frame;
-	private JPasswordField passwordField;
-	private JButton register;
-	private JTextField usernameField;
-
-	public RegisterFrame() {
-		// initialize frame
-		frameInit();
-		
-		// initialize buttons
-		buttonInit();
-
-		// initialize user input fields
-		userInputFieldInit();
-
-		// initialize labels
-		labelInit();
-	}
-	
-	public void frameInit() {
-		frame = new JFrame("Register");
-		frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
-		frame.setSize(300, 300);
-		frame.setLayout(null);
-		frame.setVisible(true);
-	}
-
-	public void buttonInit() {
-		// register register button
-		register = new JButton("Register");
-		register.setBounds(115, 196, 85, 25);
-		register.addActionListener(this);
-		frame.add(register);
-	}
-
-	public void userInputFieldInit() {
-		// register password field
-		passwordField = new JPasswordField();
-		passwordField.setBounds(105, 114, 105, 22);
-		frame.add(passwordField);
-
-		// register user name field
-		usernameField = new JTextField();
-		usernameField.setBounds(105, 79, 105, 22);
-		frame.add(usernameField);
-	}
-
-	public void labelInit() {
-		// register user name label
-		JLabel labelUsername = new JLabel("Username");
-		labelUsername.setBounds(35, 82, 76, 16);
-		frame.add(labelUsername);
-
-		// register password label
-		JLabel labelPassword = new JLabel("Password");
-		labelPassword.setBounds(35, 117, 66, 16);
-		frame.add(labelPassword);
-
-		// register label for title
-		Font font = new Font("Arial", Font.BOLD, 26);
-		JLabel labelTitle = new JLabel("Register");
-		labelTitle.setFont(font);
-		labelTitle.setBounds(35, 30, 150, 30);
-		frame.add(labelTitle);
-	}
-
-	@Override
-	public void actionPerformed(ActionEvent event) {
-		if (event.getSource() == register) {
-			
-		}
-	}
+    private JFrame frame;
+    private JPasswordField passwordField;
+    private JButton register;
+    private JTextField usernameField;
+    private JPasswordField confirmField;
+
+    public RegisterFrame() {
+        // initialize frame
+        frameInit();
+
+        // initialize buttons
+        buttonInit();
+
+        // initialize user input fields
+        userInputFieldInit();
+
+        // initialize labels
+        labelInit();
+    }
+
+    private void frameInit() {
+        frame = new JFrame("Register");
+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
+        frame.setSize(300, 300);
+        frame.setLayout(null);
+        frame.setVisible(true);
+    }
+
+    private void buttonInit() {
+        // register register button
+        register = new JButton("Register");
+        register.setBounds(115, 196, 85, 25);
+        register.addActionListener(this);
+        frame.add(register);
+    }
+
+    private void userInputFieldInit() {
+        // register password field
+        passwordField = new JPasswordField();
+        passwordField.setBounds(105, 114, 105, 22);
+        frame.add(passwordField);
+
+        // register user name field
+        usernameField = new JTextField();
+        usernameField.setBounds(105, 79, 105, 22);
+        frame.add(usernameField);
+
+        // register confirm password field
+        confirmField = new JPasswordField();
+        confirmField.setBounds(105, 149, 105, 22);
+        frame.add(confirmField);
+    }
+
+    private void labelInit() {
+        // register user name label
+        JLabel labelUsername = new JLabel("Username");
+        labelUsername.setBounds(35, 82, 76, 16);
+        frame.add(labelUsername);
+
+        // register password label
+        JLabel labelPassword = new JLabel("Password");
+        labelPassword.setBounds(35, 117, 66, 16);
+        frame.add(labelPassword);
+
+        // register confirm label
+        JLabel labelConfirm = new JLabel("Confirm");
+        labelConfirm.setBounds(35, 152, 76, 16);
+        frame.add(labelConfirm);
+
+        // register label for title
+        Font font = new Font("Arial", Font.BOLD, 26);
+        JLabel labelTitle = new JLabel("Register");
+        labelTitle.setFont(font);
+        labelTitle.setBounds(35, 30, 150, 30);
+        frame.add(labelTitle);
+    }
+
+    @Override
+    public void actionPerformed(ActionEvent event) {
+        if (event.getSource() == register) {
+            try {
+                registerAction();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private void registerAction() throws IOException {
+        String inputUsername = usernameField.getText();
+        String inputPassword = new String(passwordField.getPassword());
+        String inputConfirm = new String(confirmField.getPassword());
+        RegisterLogic obj = new RegisterLogic(inputUsername, inputPassword, inputConfirm);
+        int command = obj.register();
+
+        if (command == 1) {
+            JOptionPane.showMessageDialog(frame, "Register Success");
+            frame.dispose();
+        } else if (command == 0) {
+            JOptionPane.showMessageDialog(frame, "Password doesn't match the confirm password");
+            usernameField.setText("");
+            passwordField.setText("");
+            confirmField.setText("");
+        } else if (command == 2) {
+            JOptionPane.showMessageDialog(frame, "Username already exist.");
+            usernameField.setText("");
+            passwordField.setText("");
+            confirmField.setText("");
+        } else if (command == 3) {
+            JOptionPane.showMessageDialog(frame, "Username or password not entered.");
+            usernameField.setText("");
+            passwordField.setText("");
+            confirmField.setText("");
+        } else {
+            JOptionPane.showMessageDialog(frame, "Please enter a password and username within 15 characters");
+            usernameField.setText("");
+            passwordField.setText("");
+            confirmField.setText("");
+        }
+    }
 }
diff --git a/src/main/java/org/eom/login_control/RegisterLogic.java b/src/main/java/org/eom/login_control/RegisterLogic.java
new file mode 100644
index 0000000..a8af1ad
--- /dev/null
+++ b/src/main/java/org/eom/login_control/RegisterLogic.java
@@ -0,0 +1,71 @@
+package org.eom.login_control;
+
+import org.eom.main.FileEditor;
+import org.eom.main.FileInput;
+import org.eom.main.MainControl;
+
+import java.io.IOException;
+
+public class RegisterLogic {
+
+    private String username, password, confirm;
+
+    public RegisterLogic(String inputUsername, String inputPassword, String inputConfirm) {
+        username = inputUsername;
+        password = inputPassword;
+        confirm = inputConfirm;
+    }
+
+    public int register() throws IOException {
+        // initialize variables
+        FileEditor usernameOut = new FileEditor(MainControl.USERNAME_PATH);
+        FileEditor passwordOut = new FileEditor(MainControl.PASSWORD_PATH);
+
+        // check for correct registration password and username
+        if (checkValidInput() == 1) {
+            usernameOut.write(username);
+            passwordOut.write(password);
+            usernameOut.closeFile();
+            passwordOut.closeFile();
+            return 1;
+        } else if (checkValidInput() == 0) {
+            return 0;
+        } else if (checkValidInput() == 2) {
+            return 2;
+        } else if (checkValidInput() == 3) {
+            return 3;
+        }
+
+        return -1;
+    }
+
+    private int checkValidInput() throws IOException {
+        int result;
+        if (username.length() <= 15 && password.length() <= 15) {
+            if (username.length() > 0 && password.length() > 0) {
+                if (password.equals(confirm)) {
+                    result = 1;
+                } else {
+                    return 0;
+                }
+            } else {
+                return 3;
+            }
+        } else {
+            return -1;
+        }
+
+        FileInput usernameFile = new FileInput(MainControl.USERNAME_PATH);
+        String lineName = usernameFile.readLine();
+        while (lineName != null) {
+            if (username.equals(lineName)) {
+                usernameFile.closeFile();
+                return 2;
+            } else {
+                lineName = usernameFile.readLine();
+            }
+        }
+
+        return result;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/eom/main/FileEditor.java b/src/main/java/org/eom/main/FileEditor.java
new file mode 100644
index 0000000..9e2f157
--- /dev/null
+++ b/src/main/java/org/eom/main/FileEditor.java
@@ -0,0 +1,32 @@
+package org.eom.main;
+
+
+import java.io.BufferedWriter;
+import java.io.FileWriter;
+import java.io.IOException;
+
+public class FileEditor {
+
+    private BufferedWriter fileOut;
+
+    public FileEditor(String filePath) {
+        init(filePath);
+    }
+
+    public void init(String filePath) {
+        try {
+            fileOut = new BufferedWriter(new FileWriter(filePath, true));
+        } catch (IOException e) {
+            System.out.println("Cannot create file: " + filePath);
+        }
+    }
+
+    public void write(String content) throws IOException {
+        fileOut.write(content);
+        fileOut.newLine();
+    }
+
+    public void closeFile() throws IOException {
+        fileOut.close();
+    }
+}
diff --git a/src/main/java/org/eom/main/FileInput.java b/src/main/java/org/eom/main/FileInput.java
new file mode 100644
index 0000000..83e1840
--- /dev/null
+++ b/src/main/java/org/eom/main/FileInput.java
@@ -0,0 +1,31 @@
+package org.eom.main;
+
+import java.io.BufferedReader;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+
+public class FileInput {
+
+    private BufferedReader fileIn;
+
+    public FileInput(String filePath) {
+        init(filePath);
+    }
+
+    public void init(String filePath) {
+        try {
+            fileIn = new BufferedReader(new FileReader(filePath));
+        } catch (FileNotFoundException e) {
+            System.out.println("***Cannot open " + filePath + "***");
+        }
+    }
+
+    public String readLine() throws IOException {
+        return fileIn.readLine();
+    }
+
+    public void closeFile() throws IOException {
+        fileIn.close();
+    }
+}
diff --git a/src/main/java/org/eom/main/MainControl.java b/src/main/java/org/eom/main/MainControl.java
index 4f6166f..51abae3 100644
--- a/src/main/java/org/eom/main/MainControl.java
+++ b/src/main/java/org/eom/main/MainControl.java
@@ -1,28 +1,33 @@
 package org.eom.main;
 
 import org.eom.login_control.LoginFrame;
+import org.eom.login_control.RegisterFrame;
+import org.eom.ttt_control.CellState;
+import org.eom.ttt_control.GameGUI;
 
 
 public class MainControl {
 
-	public static final String USERNAME_PATH = "";
-	public static final String PASSWORD_PATH = "";
-		
-	public MainControl() {
-		login();
-	}
-	
-	public static void login() {
-		new LoginFrame();
-	}
-	
-	public static void register() {
-	}
-	
-	public static void TTTGame() {
-	}
-	
-	public static void main(String[] args) {
-		new MainControl();
-	}
+    public static final String USERNAME_PATH = "assets/login/username.txt";
+    public static final String PASSWORD_PATH = "assets/login/password.txt";
+
+    private MainControl() {
+        login();
+    }
+
+    public static void login() {
+        new LoginFrame();
+    }
+
+    public static void register() {
+        new RegisterFrame();
+    }
+
+    public static void TTTGame() {
+        new GameGUI(3, CellState.COMPUTER);
+    }
+
+    public static void main(String[] args) {
+        new MainControl();
+    }
 }
diff --git a/src/main/java/org/eom/ttt_control/CellState.java b/src/main/java/org/eom/ttt_control/CellState.java
new file mode 100644
index 0000000..d4eb830
--- /dev/null
+++ b/src/main/java/org/eom/ttt_control/CellState.java
@@ -0,0 +1,5 @@
+package org.eom.ttt_control;
+
+public enum CellState {
+    EMPTY, COMPUTER, HUMAN
+}
diff --git a/src/main/java/org/eom/ttt_control/ComputerPlayer.java b/src/main/java/org/eom/ttt_control/ComputerPlayer.java
new file mode 100644
index 0000000..ebd74d0
--- /dev/null
+++ b/src/main/java/org/eom/ttt_control/ComputerPlayer.java
@@ -0,0 +1,131 @@
+package org.eom.ttt_control;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+public class ComputerPlayer {
+
+    // initialize variables
+    private Map<GameState, Integer> scores = new HashMap<>();
+    private int difficulty;
+
+    /**
+     * Constructor
+     *
+     * @param difficulty the difficulty of computer player
+     */
+    public ComputerPlayer(int difficulty) {
+        this.difficulty = difficulty;
+
+        scores.put(GameState.COMPUTER_WIN, 1);
+        scores.put(GameState.HUMAN_WIN, -1);
+        scores.put(GameState.DRAW, 0);
+    }
+
+    /**
+     * This method calls on corresponding methods depending
+     * on the difficulty of the computer player
+     *
+     * @param board  the game board object
+     * @param player the player that have to move
+     * @return an array with two elements representing the move
+     */
+    public int[] getMove(GameBoard board, CellState player) {
+        if (difficulty == 0) {
+            return randomMoveGenerator(board);
+        } else {
+            return alphaBetaPruning(board, player, -2, 2);
+        }
+    }
+
+    /**
+     * This method sets the difficulty of the computer player
+     *
+     * @param difficulty the new difficulty
+     */
+    public void setDifficulty(int difficulty) {
+        this.difficulty = difficulty;
+    }
+
+    /**
+     * This method uses alpha-beta-pruning (minimax) to search for
+     * all possible opponent moves with a given board. It will create a
+     * clone game board object and simulate all the moves on the clone board.
+     * The moves are then scored and the highest score move is chose to be returned
+     * (Medium and Hard level)
+     *
+     * @param board  the game board object
+     * @param player the player that have to move
+     * @param alpha  maximum lower bound of possible solutions
+     * @param beta   minimum upper bound of possible solutions
+     * @return an array with two elements representing the move
+     */
+    private int[] alphaBetaPruning(GameBoard board, CellState player, int alpha, int beta) {
+        CellState otherPlayer = GameBoard.switchPlayer(player);
+        int bestScore = -2;
+        int bestRow = -1;
+        int bestCol = -1;
+
+        if (board.checkWin() != GameState.PLAYING) {
+            return new int[]{scores.get(board.checkWin()), bestRow, bestCol};
+        }
+
+        List<int[]> emptySquares = board.getEmptySquare();
+        int depth = 0;
+        if (difficulty == 1) {
+            depth = emptySquares.size() / 2;
+        } else if (difficulty == 2) {
+            depth = emptySquares.size();
+        }
+
+        for (int i = 0; i < depth; i++) {
+            int[] move = emptySquares.get(i);
+            GameBoard trial = board.clone();
+            trial.setState(move[0], move[1], player);
+            int score = alphaBetaPruning(trial, otherPlayer, -beta, -Integer.max(alpha, bestScore))[0];
+            alpha = score * getScore(player);
+
+            if (alpha == 1) {
+                return new int[]{score, move[0], move[1]};
+            } else if (alpha > bestScore) {
+                bestScore = alpha;
+                bestRow = move[0];
+                bestCol = move[1];
+            }
+
+            if (bestScore >= beta) {
+                break;
+            }
+        }
+
+        return new int[]{bestScore * getScore(player), bestRow, bestCol};
+    }
+
+    /**
+     * This method find all the possible move for computer player
+     * and returns a random one as computer move. (Easy level)
+     *
+     * @param board the game board object
+     * @return an array with two elements representing the move
+     */
+    private int[] randomMoveGenerator(GameBoard board) {
+        Random random = new Random();
+        List<int[]> emptySquares = board.getEmptySquare();
+        int index = random.nextInt(emptySquares.size() - 1);
+        return new int[]{0, emptySquares.get(index)[0], emptySquares.get(index)[1]};
+    }
+
+    /**
+     * This method returns a score from score map with given player
+     *
+     * @param player the player that has to get score
+     * @return the corresponding score from score map.
+     */
+    private int getScore(CellState player) {
+        return scores.get((player == CellState.COMPUTER) ? GameState.COMPUTER_WIN : GameState.HUMAN_WIN);
+    }
+
+
+}
diff --git a/src/main/java/org/eom/ttt_control/GameBoard.java b/src/main/java/org/eom/ttt_control/GameBoard.java
new file mode 100644
index 0000000..e7ea0fd
--- /dev/null
+++ b/src/main/java/org/eom/ttt_control/GameBoard.java
@@ -0,0 +1,164 @@
+package org.eom.ttt_control;
+
+import java.util.*;
+
+public class GameBoard {
+
+    // initialize variables
+    private CellState[][] board = new CellState[3][3];
+    private int dim;
+
+    /**
+     * Constructor: assuming no given board, will fill up the board
+     * variable with EMPTY.
+     *
+     * @param dim the size of the game board
+     */
+    public GameBoard(int dim) {
+        this.dim = dim;
+
+        for (int row = 0; row < dim; row++) {
+            for (int col = 0; col < dim; col++) {
+                board[row][col] = CellState.EMPTY;
+            }
+        }
+    }
+
+    /**
+     * Constructor: has a given board, will have the board variable
+     * equal to the given board
+     *
+     * @param dim   the size of the game board
+     * @param board a given board
+     */
+    public GameBoard(int dim, CellState[][] board) {
+        this.dim = dim;
+
+        for (int row = 0; row < dim; row++) {
+            System.arraycopy(board[row], 0, this.board[row], 0, dim);
+        }
+    }
+
+    /**
+     * This method will return the opponent player of the given player
+     *
+     * @param player the given player
+     * @return the opponent player
+     */
+    public static CellState switchPlayer(CellState player) {
+        return (player == CellState.COMPUTER) ? CellState.HUMAN : CellState.COMPUTER;
+    }
+
+    /**
+     * This method will returns the player on a specific cell on the board
+     *
+     * @param row    the row index of array
+     * @param column the column index of array
+     * @return the player on the given index cell
+     */
+    public CellState getCell(int row, int column) {
+        return board[row][column];
+    }
+
+    /**
+     * This method will add the given player into the specific cell given.
+     *
+     * @param row    the row index of array
+     * @param col    the col index of array
+     * @param player the player that will be put on the cell
+     */
+    public void setState(int row, int col, CellState player) {
+        if (board[row][col] == CellState.EMPTY) {
+            board[row][col] = player;
+        }
+    }
+
+    /**
+     * This method will loop through the board variable and add the index
+     * of EMPTY cells into a list.
+     *
+     * @return the list of indices of EMPTY cells
+     */
+    public List<int[]> getEmptySquare() {
+        // create a list that will contain all the empty squares
+        List<int[]> empty = new ArrayList<>();
+
+        // find empty squares on the board and add it to the list
+        for (int row = 0; row < board.length; row++) {
+            for (int column = 0; column < board.length; column++) {
+                if (board[row][column] == CellState.EMPTY) {
+                    empty.add(new int[]{row, column});
+                }
+            }
+        }
+
+        return empty;
+    }
+
+    /**
+     * This method will add all possible win solution into a list. It will
+     * then loop through the list and turn each win solution into a set, which
+     * will merge all common element into a single element. By determining what
+     * the single element is, the method will return the winner
+     *
+     * @return current game state
+     */
+    public GameState checkWin() {
+        CellState[][] cloneBoard = board;
+        List<CellState[]> lines = new ArrayList<>();
+
+        // rows
+        Collections.addAll(lines, cloneBoard);
+
+        // columns
+        CellState[][] column = new CellState[dim][dim];
+        for (int i = 0; i < dim; i++) {
+            for (int j = 0; j < dim; j++) {
+                column[i][j] = cloneBoard[j][i];
+            }
+        }
+
+        Collections.addAll(lines, column);
+
+        // diagnose
+        CellState[] diagOne = new CellState[dim];
+        CellState[] diagTwo = new CellState[dim];
+
+        for (int i = 0; i < dim; i++) {
+            diagOne[i] = cloneBoard[i][i];
+            diagTwo[i] = cloneBoard[i][dim - i - 1];
+        }
+
+        lines.add(diagOne);
+        lines.add(diagTwo);
+
+        // check every line for win situation
+        for (CellState[] line : lines) {
+            Set<CellState> setLine = new HashSet<>();
+            Collections.addAll(setLine, line);
+
+            if (setLine.size() == 1 && !setLine.contains(CellState.EMPTY)) {
+                return (line[0] == CellState.COMPUTER) ? GameState.COMPUTER_WIN : GameState.HUMAN_WIN;
+            }
+        }
+
+        // no winner, check for draw
+        List<int[]> empty = getEmptySquare();
+        if (empty.size() == 0) {
+            return GameState.DRAW;
+        }
+
+        // game still in progress
+        return GameState.PLAYING;
+    }
+
+    /**
+     * This method clones the same game board
+     *
+     * @return the cloned game board object
+     */
+    @Override
+    public GameBoard clone() {
+        return new GameBoard(dim, board);
+    }
+}
diff --git a/src/main/java/org/eom/ttt_control/GameGUI.java b/src/main/java/org/eom/ttt_control/GameGUI.java
new file mode 100644
index 0000000..50454a2
--- /dev/null
+++ b/src/main/java/org/eom/ttt_control/GameGUI.java
@@ -0,0 +1,334 @@
+package org.eom.ttt_control;
+
+import org.eom.main.MainControl;
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+
+public class GameGUI implements ActionListener {
+
+    // GUI setup
+    private JFrame frame;
+    private JButton[][] buttons;
+    private JPanel gameBoard;
+    private JPanel mainPanel;
+    private JLabel statusBar;
+
+    private JMenuItem setDiff;
+    private JMenuItem switchUser;
+    private JMenuItem computerWins;
+    private JMenuItem humanWins;
+    private JMenuItem draws;
+    private JMenuItem instruction;
+
+    // game board
+    private int size;
+
+    // AI setup
+    private CellState humanPlayer;
+    private CellState aiPlayer;
+
+    // other game control variables
+    private GameBoard board;
+    private ComputerPlayer computer;
+    private GameState currentState;
+    private CellState currentPlayer;
+    private int difficulty = 2;
+    private int numWinComputer = 0;
+    private int numWinHuman = 0;
+    private int numDraw = 0;
+
+    /**
+     * Constructor that calls gameSetup method
+     *
+     * @param dim      the size of the game board
+     * @param aiPlayer the computer player
+     */
+    public GameGUI(int dim, CellState aiPlayer) {
+        gameSetup(dim, aiPlayer);
+    }
+
+    /**
+     * The method initialize variables and calls
+     * other init methods
+     *
+     * @param dim      the size of the game board
+     * @param aiPlayer the computer player
+     */
+    private void gameSetup(int dim, CellState aiPlayer) {
+        // variables initialization
+        this.size = dim;
+        this.aiPlayer = aiPlayer;
+        humanPlayer = GameBoard.switchPlayer(aiPlayer);
+
+        // initialize frame
+        guiInit();
+
+        // set up a new game
+        newGame();
+
+        // set up game board
+        boardSetUp();
+    }
+
+    /**
+     * The method initialize and register all
+     * GUI component of the game.
+     */
+    private void guiInit() {
+        // initialize frame
+        frame = new JFrame("Tic Tac Toe");
+        frame.setSize(size * 100, size * 100 + 60);
+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
+        frame.setLocationRelativeTo(null);
+        frame.setVisible(true);
+
+        // initialize main panel
+        mainPanel = new JPanel();
+        mainPanel.setLayout(new BorderLayout(3, 3));
+        frame.add(mainPanel);
+
+        // initialize status bar
+        statusBar = new JLabel("         ");
+        statusBar.setFont(new Font(Font.DIALOG_INPUT, Font.BOLD, 14));
+        statusBar.setBorder(BorderFactory.createEmptyBorder(2, 5, 4, 5));
+        statusBar.setOpaque(true);
+        statusBar.setBackground(Color.LIGHT_GRAY);
+        frame.add(statusBar, BorderLayout.PAGE_END);
+
+        // initialize menu bar
+        JMenuBar menuBar = new JMenuBar();
+        frame.add(menuBar, BorderLayout.PAGE_START);
+
+        JMenu setting = new JMenu("Setting");
+        menuBar.add(setting);
+
+        setDiff = new JMenuItem("Set Difficulty");
+        setDiff.addActionListener(this);
+        setting.add(setDiff);
+
+        switchUser = new JMenuItem("Switch User");
+        switchUser.addActionListener(this);
+        setting.add(switchUser);
+
+        instruction = new JMenuItem("Instruction");
+        instruction.addActionListener(this);
+        setting.add(instruction);
+
+        JMenu stats = new JMenu("Stats");
+        menuBar.add(stats);
+
+        computerWins = new JMenuItem("Computer Wins: " + numWinComputer);
+        stats.add(computerWins);
+
+        humanWins = new JMenuItem("Human Wins: " + numWinHuman);
+        stats.add(humanWins);
+
+        draws = new JMenuItem("Draws: " + numDraw);
+        stats.add(draws);
+    }
+
+    /**
+     * This method initialize the game board
+     * panel and add all the buttons into the
+     * panel.
+     */
+    private void boardSetUp() {
+        // game board setup
+        buttons = new JButton[size][size];
+        gameBoard = new JPanel();
+        gameBoard.setLayout(new GridLayout(size, size, 4, 4));
+        gameBoard.setBackground(Color.black);
+
+        for (int row = 0; row < size; row++) {
+            for (int col = 0; col < size; col++) {
+                buttons[row][col] = new JButton();
+                buttons[row][col].setSize(100, 100);
+                buttons[row][col].addActionListener(this);
+                buttons[row][col].setBackground(Color.white);
+                gameBoard.add(buttons[row][col]);
+            }
+        }
+
+        // add game board onto frame
+        mainPanel.add(gameBoard);
+    }
+
+    /**
+     * This method initialize all the game
+     * control variables and objects
+     */
+    private void newGame() {
+        board = new GameBoard(size);
+        computer = new ComputerPlayer(difficulty);
+        currentPlayer = CellState.HUMAN;
+        currentState = GameState.PLAYING;
+    }
+
+    /**
+     * This method receive the location of the button
+     * clicked by human player and update the color of
+     * the button. It also update the state of the game
+     * and calls aiPlayer.
+     *
+     * @param row the row index of button clicked
+     * @param col the column index of button clicked
+     */
+    private void humanMove(int row, int col) {
+        if (currentState == GameState.PLAYING && currentPlayer == humanPlayer) {
+            if (board.getCell(row, col) == CellState.EMPTY) {
+                board.setState(row, col, humanPlayer);
+                buttons[row][col].setBackground(Color.blue);
+                buttons[row][col].setEnabled(false);
+                currentPlayer = aiPlayer;
+
+                GameState winner = board.checkWin();
+                if (winner != GameState.PLAYING) {
+                    gameOver(winner);
+                } else {
+                    updateStatusBar();
+                }
+
+                aiMove();
+            }
+        }
+    }
+
+    /**
+     * This method calls getMove() method from ComputerPlayer
+     * class. It will receive the move it should make and updates
+     * the color of the button. It also update the state of the game
+     */
+    private void aiMove() {
+        if (currentState == GameState.PLAYING && currentPlayer == aiPlayer) {
+            int[] result = computer.getMove(board, aiPlayer);
+            int[] move = new int[]{result[1], result[2]};
+            if (board.getCell(move[0], move[1]) == CellState.EMPTY) {
+                board.setState(move[0], move[1], aiPlayer);
+                buttons[move[0]][move[1]].setBackground(Color.red);
+                buttons[move[0]][move[1]].setEnabled(false);
+                currentPlayer = humanPlayer;
+
+                GameState winner = board.checkWin();
+                if (winner != GameState.PLAYING) {
+                    gameOver(winner);
+                } else {
+                    updateStatusBar();
+                }
+            }
+        }
+    }
+
+    /**
+     * This method will end the game and do necessary
+     * actions depending on the game state.
+     *
+     * @param winner a end game GameState
+     */
+    private void gameOver(GameState winner) {
+        currentState = winner;
+        updateStatusBar();
+
+        mainPanel.remove(gameBoard);
+        JButton playAgain = new JButton("Play Again!");
+        playAgain.addActionListener(e -> {
+            frame.dispose();
+            gameSetup(size, aiPlayer);
+        });
+
+        Font font = new Font("Monospaced", Font.BOLD, 20);
+        playAgain.setFont(font);
+        playAgain.setOpaque(false);
+        playAgain.setContentAreaFilled(false);
+        playAgain.setBorderPainted(false);
+
+        mainPanel.add(playAgain, BorderLayout.CENTER, 0);
+
+        if (winner == GameState.COMPUTER_WIN) {
+            numWinComputer++;
+            computerWins.setText("Computer: " + numWinComputer);
+        } else if (winner == GameState.HUMAN_WIN) {
+            numWinHuman++;
+            humanWins.setText("Human: " + numWinHuman);
+        } else if (winner == GameState.DRAW) {
+            numDraw++;
+            draws.setText("Draws: " + numDraw);
+        }
+    }
+
+    /**
+     * This method update the status bar (JLabel) on the
+     * bottom of the frame
+     */
+    private void updateStatusBar() {
+        if (currentState == GameState.PLAYING) {
+            statusBar.setForeground(Color.black);
+            if (currentPlayer == CellState.COMPUTER) {
+                statusBar.setText("Computer Player's Turn");
+            } else {
+                statusBar.setText("Human Player's Turn");
+            }
+        } else if (currentState == GameState.COMPUTER_WIN) {
+            statusBar.setForeground(Color.red);
+            statusBar.setText("Computer Win! Click to play again.");
+        } else if (currentState == GameState.HUMAN_WIN) {
+            statusBar.setForeground(Color.red);
+            statusBar.setText("Human Win! Click to play again.");
+        } else if (currentState == GameState.DRAW) {
+            statusBar.setForeground(Color.red);
+            statusBar.setText("It's a Draw! Click to play again");
+        }
+    }
+
+    /**
+     * This method is an event handler for setDiff
+     * menuItem. It sets the difficulty of the computer
+     * player.
+     */
+    private void setDifficulty() {
+        int choice = JOptionPane.showOptionDialog(frame, "Select Difficulty", "Set Difficulty",
+                JOptionPane.OK_OPTION, JOptionPane.QUESTION_MESSAGE, null,
+                new String[]{"Easy", "Medium", "Hard"}, 1);
+
+        if (choice == 0) {
+            difficulty = 0;
+            frame.dispose();
+            gameSetup(size, aiPlayer);
+            computer.setDifficulty(difficulty);
+        } else if (choice == 1) {
+            difficulty = 1;
+            frame.dispose();
+            gameSetup(size, aiPlayer);
+            computer.setDifficulty(difficulty);
+        } else if (choice == 2) {
+            difficulty = 2;
+            frame.dispose();
+            gameSetup(size, aiPlayer);
+            computer.setDifficulty(difficulty);
+        }
+    }
+
+    @Override
+    public void actionPerformed(ActionEvent e) {
+        for (int i = 0; i < size; i++) {
+            for (int j = 0; j < size; j++) {
+                if (e.getSource() == buttons[i][j]) {
+                    humanMove(i, j);
+                }
+            }
+        }
+
+        if (e.getSource() == setDiff) {
+            setDifficulty();
+        } else if (e.getSource() == switchUser) {
+            frame.dispose();
+            MainControl.login();
+        } else if (e.getSource() == instruction) {
+            JOptionPane.showMessageDialog(frame, "Tic-tac-toe (also known as noughts and crosses or Xs and Os) is a" +
+                    "game for two players, X and O, who take turns marking the spaces in a 3Ã—3 grid.\nThe player who succeeds " +
+                    "in placing three of their marks in a horizontal, vertical, or diagonal row wins the game.", "Instruction", JOptionPane.INFORMATION_MESSAGE);
+        }
+    }
+}
diff --git a/src/main/java/org/eom/ttt_control/GameState.java b/src/main/java/org/eom/ttt_control/GameState.java
index 6d22872..be0c7a1 100644
--- a/src/main/java/org/eom/ttt_control/GameState.java
+++ b/src/main/java/org/eom/ttt_control/GameState.java
@@ -1,5 +1,5 @@
 package org.eom.ttt_control;
 
 public enum GameState {
-	EMPTY, COMPUTER, HUMAN, DRAW, PLAYING
+    PLAYING, DRAW, COMPUTER_WIN, HUMAN_WIN
 }
diff --git a/src/main/java/org/eom/ttt_control/TTTBoard.java b/src/main/java/org/eom/ttt_control/TTTBoard.java
deleted file mode 100644
index 1a4b228..0000000
--- a/src/main/java/org/eom/ttt_control/TTTBoard.java
+++ /dev/null
@@ -1,129 +0,0 @@
-package org.eom.ttt_control;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-public class TTTBoard {
-
-	// create useful variables
-	GameState[][] board = new GameState[3][3];
-	private int dim;
-
-	
-	public TTTBoard(int dim) {
-		this.dim = dim;
-		
-		for (int row = 0; row < 3; row++) {
-			for (int col = 0; col < 3; col++) {
-				board[row][col] = GameState.EMPTY;
-			}
-		}
-	}
-	
-	public TTTBoard(int dim, GameState[][] board) {
-		this.dim = dim;
-		this.board = board;
-	}
-
-	public GameState square(int row, int column) {
-		return board[row][column];
-	}
-
-	public void addState(int row, int col, GameState player) {
-		if (board[row][col] == GameState.EMPTY) {
-			board[row][col] = player;
-		}
-	}
-	
-	public void removeState(int row, int col) {
-		if (board[row][col] != GameState.EMPTY) {
-			board[row][col] = GameState.EMPTY;
-		}
-	}
-
-	public List<int[]> getEmptySquare() {
-		// create a list that will contain all the empty squares
-		List<int[]> empty = new ArrayList<int[]>();
-
-		// find empty squares on the board and add it to the list
-		for (int row = 0; row < board.length; row++) {
-			for (int column = 0; column < board.length; column++) {
-				if (board[row][column] == GameState.EMPTY) {
-					empty.add(new int[] { row, column });
-				}
-			}
-		}
-
-		return empty;
-	}
-
-	public GameState checkWin() {
-		GameState[][] cloneBoard = board;
-		List<GameState[]> lines = new ArrayList<GameState[]>();
-
-		// rows
-		for (GameState[] row : cloneBoard) {
-			lines.add(row);
-		}
-
-		// columns
-		GameState[][] column = new GameState[dim][dim];
-		for (int i = 0; i < dim; i++) {
-			for (int j = 0; j < dim; j++) {
-				column[i][j] = cloneBoard[j][i];
-			}
-		}
-
-		for (GameState[] col : column) {
-			lines.add(col);
-		}
-
-		// diagnose
-		GameState[] diagOne = new GameState[dim];
-		GameState[] diagTwo = new GameState[dim];
-
-		for (int i = 0; i < dim; i++) {
-			diagOne[i] = cloneBoard[i][i];
-			diagTwo[i] = cloneBoard[i][dim - i - 1];
-		}
-
-		lines.add(diagOne);
-		lines.add(diagTwo);
-
-		// check every line for win situation
-		for (GameState[] line : lines) {
-			Set<GameState> setLine = new HashSet<GameState>();
-			for (GameState number : line) {
-				setLine.add(number);
-			}
-
-			if (setLine.size() == 1 && !setLine.contains(GameState.EMPTY)) {
-				return line[0];
-			}
-		}
-
-		// no winner, check for draw
-		List<int[]> empty = getEmptySquare();
-		if (empty.size() == 0) {
-			return GameState.DRAW;
-		}
-
-		// game still in progress
-		return GameState.PLAYING;
-	}
-
-	public TTTBoard clone() {
-		return new TTTBoard(dim, board);
-	}
-
-	public static GameState switchPlayer(GameState player) {
-		if (player == GameState.COMPUTER) {
-			return GameState.HUMAN;
-		} else {
-			return GameState.COMPUTER;
-		}
-	}
-
-}
diff --git a/src/main/java/org/eom/ttt_control/TTTGUI.java b/src/main/java/org/eom/ttt_control/TTTGUI.java
deleted file mode 100644
index 7d1df35..0000000
--- a/src/main/java/org/eom/ttt_control/TTTGUI.java
+++ /dev/null
@@ -1,185 +0,0 @@
-package org.eom.ttt_control;
-
-import java.awt.Color;
-import java.awt.GridLayout;
-import java.awt.event.ActionEvent;
-import java.awt.event.ActionListener;
-
-import javax.swing.JButton;
-import javax.swing.JFrame;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-
-public class TTTGUI implements ActionListener {
-
-	// GUI setup
-	private JFrame frame;
-	private JButton[][] boardButton;
-	private Color[] colour = { Color.WHITE, Color.BLUE, Color.RED, Color.BLACK };
-	private JPanel gameBoard;
-
-	// game board
-	private int size;
-	private GameState turn;
-
-	// AI setup
-	public static GameState humanPlayer;
-	public static GameState aiPlayer;
-
-	// other game control variables
-	private TTTBoard board;
-	private TTTPlayer player;
-	private boolean inProgress;
-	private boolean wait;
-
-	public static void main(String[] args) {
-		new TTTGUI(3, GameState.COMPUTER);
-	}
-
-	// constructor
-	public TTTGUI(int dim, GameState aiPlayer) {
-		// variables initialization
-		this.size = dim;
-		TTTGUI.aiPlayer = aiPlayer;
-		humanPlayer = TTTBoard.switchPlayer(aiPlayer);
-
-		// initialize frame
-		frameInit();
-
-		// set up a new game
-		newGame();
-
-		// set up game board
-		boardSetUp();
-	}
-
-	public void boardSetUp() {
-		// game board setup
-		boardButton = new JButton[size][size];
-		gameBoard = new JPanel();
-		gameBoard.setLayout(new GridLayout(size, size, 4, 4));
-		gameBoard.setBackground(colour[3]);
-
-		for (int row = 0; row < size; row++) {
-			for (int column = 0; column < size; column++) {
-				boardButton[row][column] = new JButton();
-				boardButton[row][column].setSize(100, 100);
-				boardButton[row][column].setBackground(colour[0]);
-				boardButton[row][column].addActionListener(this);
-				gameBoard.add(boardButton[row][column]);
-			}
-		}
-
-		// add game board onto frame
-		frame.add(gameBoard);
-	}
-	
-	public void frameInit() {
-		frame = new JFrame("Tic Tac Toe");
-		frame.setSize(size * 100, size * 100 + 30);
-		frame.pack();
-		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-		frame.setLocationRelativeTo(null);
-		frame.setVisible(true);
-	}
-
-	public void newGame() {
-		board = new TTTBoard(size);
-		player = new TTTPlayer();
-		inProgress = true;
-		wait = false;
-		turn = GameState.COMPUTER;
-	}
-
-	@Override
-	public void actionPerformed(ActionEvent event) {
-		for (int row = 0; row < size; row++) {
-			for (int column = 0; column < size; column++) {
-				if (event.getSource() == boardButton[row][column]) {
-					humanMove(row, column);
-				}
-			}
-		}
-	}
-
-	public void humanMove(int row, int column) {
-		if (inProgress && turn == humanPlayer) {
-			if (board.square(row, column) == GameState.EMPTY) {
-				board.addState(row, column, humanPlayer);
-				turn = aiPlayer;
-				
-				updateGUI();
-				
-				GameState winner = board.checkWin();
-				if (winner != null) {
-					gameOver(winner);
-				}
-				
-				wait = true;
-			}
-		}
-	}
-	
-	public void aiMove() {
-		/*
-		if (inProgress && turn == aiPlayer) {
-			int[] move = (int[]) player.mmMove(board, aiPlayer).get(1);
-			if (board.square(move[0], move[1]) == GameState.EMPTY) {
-				board.move(move[0], move[1], aiPlayer);
-				turn = humanPlayer;
-				
-				updateGUI();
-				
-				GameState winner = board.checkWin();
-				if (winner != null) {
-					gameOver(winner);
-				}
-			}
-		}*/
-	}
-
-	public void gameOver(GameState winner) {
-		if (winner == GameState.COMPUTER) {
-			JOptionPane.showMessageDialog(gameBoard, "Player Red wins!");
-		} else if (winner == GameState.COMPUTER) {
-			JOptionPane.showMessageDialog(gameBoard, "Player Blue wins!");
-		} else if (winner == GameState.DRAW) {
-			JOptionPane.showMessageDialog(gameBoard, "It is a tie!");
-		}
-
-		inProgress = false;
-
-		int choice = JOptionPane.showOptionDialog(gameBoard, "Game Over, Would You Like To Play Again?", "GameOver",
-				JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null,
-				new String[] { "Play Again", "Exit" }, 1);
-
-		if (choice == 0) {
-			new TTTGUI(size, aiPlayer);
-		} else {
-			System.exit(1);
-		}
-	}
-
-	public void updateGUI() {
-		for (int row = 0; row < size; row++) {
-			for (int column = 0; column < size; column++) {
-				GameState symbol = board.square(row, column);
-				System.out.print(symbol + " ");
-				if (symbol == GameState.HUMAN) {
-					boardButton[row][column].setBackground(colour[1]);
-					boardButton[row][column].setEnabled(false);
-				} else if (symbol == GameState.COMPUTER) {
-					boardButton[row][column].setBackground(colour[2]);
-					boardButton[row][column].setEnabled(false);
-				}
-			}
-		}
-		
-		if (wait) {
-			aiMove();
-		} else {
-			wait = true;
-		}
-		System.out.println("\n");
-	}
-}
diff --git a/src/main/java/org/eom/ttt_control/TTTPlayer.java b/src/main/java/org/eom/ttt_control/TTTPlayer.java
deleted file mode 100644
index 439dbad..0000000
--- a/src/main/java/org/eom/ttt_control/TTTPlayer.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.eom.ttt_control;
-
-import java.util.HashMap;
-import java.util.Map;
-
-public class TTTPlayer {
-
-	public Map<GameState, Integer> scores = new HashMap<>();
-
-	public TTTPlayer() {
-		scores.put(GameState.COMPUTER, 1);
-		scores.put(GameState.HUMAN, -1);
-		scores.put(GameState.DRAW, 0);
-	}
-
-	public int[] miniMax(TTTBoard board, GameState player) {
-		return alphaBetaPruning(board, player, -2, 2);
-	}
-
-	public int[] alphaBetaPruning(TTTBoard board, GameState player, int alpha, int beta) {
-		GameState otherPlayer = TTTBoard.switchPlayer(player);
-		int bestScore = -2;
-		int bestRow = -1;
-		int bestCol = -1;
-
-		if (board.checkWin() != GameState.PLAYING) {
-			return new int[] { scores.get(board.checkWin()), bestRow, bestCol };
-		}
-
-		for (int[] move : board.getEmptySquare()) {
-			TTTBoard trial = board.clone();
-			trial.addState(move[0], move[1], player);
-			int score = alphaBetaPruning(trial, otherPlayer, -beta, -Integer.max(alpha, bestScore))[0];
-			alpha = score * scores.get(player);
-			trial.removeState(move[0], move[1]);
-
-			if (alpha == 1) {
-				return new int[] { score, move[0], move[1] };
-			} else if (alpha > bestScore) {
-				bestScore = alpha;
-				bestRow = move[0];
-				bestCol = move[1];
-			}
-			
-			if (bestScore >= beta) {
-				break;
-			}
-		}
-
-		return new int[] { bestScore * scores.get(player), bestRow, bestCol };
-	}
-}
diff --git a/src/test/java/org/eom/aitest/TTTPlayerTest1.java b/src/test/java/org/eom/aitest/TTTPlayerTest1.java
deleted file mode 100644
index e109fe3..0000000
--- a/src/test/java/org/eom/aitest/TTTPlayerTest1.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.eom.aitest;
-
-import static org.junit.Assert.*;
-
-import org.eom.ttt_control.GameState;
-import org.eom.ttt_control.TTTBoard;
-import org.eom.ttt_control.TTTPlayer;
-import org.junit.Test;
-
-public class TTTPlayerTest1 {
-
-	@Test
-	public void testmmMove() {
-
-		GameState[][] board = { { GameState.HUMAN, GameState.HUMAN, GameState.COMPUTER },
-				{ GameState.EMPTY, GameState.HUMAN, GameState.HUMAN },
-				{ GameState.COMPUTER, GameState.EMPTY, GameState.COMPUTER } };
-		TTTPlayer obj = new TTTPlayer();
-		int[] result = obj.miniMax(new TTTBoard(3, board), GameState.COMPUTER);
-		int row = result[1];
-		int col = result[2];
-		System.out.println(row);
-		System.out.println(col);
-		assertEquals("Bad Move X: " + row, 2, row);
-		assertEquals("Bad Move Y: " + col, 1, col);
-	}
-}
diff --git a/src/test/java/org/eom/aitest/TTTPlayerTest2.java b/src/test/java/org/eom/aitest/TTTPlayerTest2.java
deleted file mode 100644
index 18b2052..0000000
--- a/src/test/java/org/eom/aitest/TTTPlayerTest2.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.eom.aitest;
-
-import static org.junit.Assert.*;
-
-import org.eom.ttt_control.GameState;
-import org.eom.ttt_control.TTTBoard;
-import org.eom.ttt_control.TTTPlayer;
-import org.junit.Test;
-
-public class TTTPlayerTest2 {
-
-	@Test
-	public void testmmMove() {
-		GameState[][] board = {{GameState.HUMAN, GameState.COMPUTER, GameState.HUMAN}, 
-				{GameState.HUMAN, GameState.HUMAN, GameState.COMPUTER}, 
-				{GameState.EMPTY, GameState.EMPTY, GameState.COMPUTER}};
-		TTTPlayer obj = new TTTPlayer();
-		int[] result = obj.miniMax(new TTTBoard(3, board), GameState.COMPUTER);
-		int row = result[1];
-		int col = result[2];
-		System.out.println(row);
-		System.out.println(col);
-		assertEquals("Bad Move X: " + row, 2, row);
-		assertEquals("Bad Move Y: " + col, 0, col);
-	}
-
-}
diff --git a/src/test/java/org/eom/aitest/TTTPlayerTest3.java b/src/test/java/org/eom/aitest/TTTPlayerTest3.java
deleted file mode 100644
index 5720694..0000000
--- a/src/test/java/org/eom/aitest/TTTPlayerTest3.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.eom.aitest;
-
-import static org.junit.Assert.*;
-
-import org.eom.ttt_control.GameState;
-import org.eom.ttt_control.TTTBoard;
-import org.eom.ttt_control.TTTPlayer;
-import org.junit.Test;
-
-public class TTTPlayerTest3 {
-
-	@Test
-	public void testmmMove() {
-		GameState[][] board = {{GameState.HUMAN, GameState.HUMAN, GameState.EMPTY}, 
-				{GameState.COMPUTER, GameState.COMPUTER, GameState.HUMAN}, 
-				{GameState.COMPUTER, GameState.EMPTY, GameState.EMPTY}};
-		TTTPlayer obj = new TTTPlayer();
-		int[] result = obj.miniMax(new TTTBoard(3, board), GameState.COMPUTER);
-		int row = result[1];
-		int col = result[2];
-		System.out.println(row);
-		System.out.println(col);
-		assertEquals("Bad Move X: " + row, 0, row);
-		assertEquals("Bad Move Y: " + col, 2, col);
-	}
-
-}
diff --git a/src/test/java/org/eom/aitest/TTTPlayerTest4.java b/src/test/java/org/eom/aitest/TTTPlayerTest4.java
deleted file mode 100644
index f879aed..0000000
--- a/src/test/java/org/eom/aitest/TTTPlayerTest4.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.eom.aitest;
-
-import static org.junit.Assert.*;
-
-import org.eom.ttt_control.GameState;
-import org.eom.ttt_control.TTTBoard;
-import org.eom.ttt_control.TTTPlayer;
-import org.junit.Test;
-
-public class TTTPlayerTest4 {
-
-	@Test
-	public void testmmMove() {
-		GameState[][] board = {{GameState.COMPUTER, GameState.HUMAN, GameState.HUMAN}, 
-				{GameState.EMPTY, GameState.COMPUTER, GameState.EMPTY}, 
-				{GameState.HUMAN, GameState.COMPUTER, GameState.HUMAN}};
-		TTTPlayer obj = new TTTPlayer();
-		int[] result = obj.miniMax(new TTTBoard(3, board), GameState.COMPUTER);
-		int row = result[1];
-		int col = result[2];
-		System.out.println(row);
-		System.out.println(col);
-		assertEquals("Bad Move X: " + row, 1, row);
-		assertEquals("Bad Move Y: " + col, 2, col);
-	}
-
-}
diff --git a/src/test/java/org/eom/ttt_control/ComputerPlayerTest.java b/src/test/java/org/eom/ttt_control/ComputerPlayerTest.java
new file mode 100644
index 0000000..7368daa
--- /dev/null
+++ b/src/test/java/org/eom/ttt_control/ComputerPlayerTest.java
@@ -0,0 +1,134 @@
+package org.eom.ttt_control;
+
+import static org.junit.Assert.*;
+
+import org.junit.Test;
+
+public class ComputerPlayerTest {
+
+    @Test
+    public void testMinimaxWinRow() {
+        /*
+        x x o
+          x x
+        o   o
+
+        Check if computer knows how to win the game with win case
+        on a row of the board
+         */
+        CellState[][] board = {{CellState.HUMAN, CellState.HUMAN, CellState.COMPUTER},
+                {CellState.EMPTY, CellState.HUMAN, CellState.HUMAN},
+                {CellState.COMPUTER, CellState.EMPTY, CellState.COMPUTER}};
+        ComputerPlayer obj = new ComputerPlayer(2);
+        int[] result = obj.getMove(new GameBoard(3, board), CellState.COMPUTER);
+        int row = result[1];
+        int col = result[2];
+        assertEquals("Bad Move X: " + row, 2, row);
+        assertEquals("Bad Move Y: " + col, 1, col);
+    }
+
+    @Test
+    public void testMinimaxWinCol() {
+        /*
+        x
+        o o x
+        x o x
+
+        Check if computer knows how to win the game with win case
+        on a column of the board
+         */
+        CellState[][] board = {{CellState.HUMAN, CellState.EMPTY, CellState.EMPTY},
+                {CellState.COMPUTER, CellState.COMPUTER, CellState.HUMAN},
+                {CellState.HUMAN, CellState.COMPUTER, CellState.HUMAN}};
+        ComputerPlayer obj = new ComputerPlayer(2);
+        int[] result = obj.getMove(new GameBoard(3, board), CellState.COMPUTER);
+        int row = result[1];
+        int col = result[2];
+        assertEquals("Bad Move X: " + row, 0, row);
+        assertEquals("Bad Move Y: " + col, 1, col);
+    }
+
+    @Test
+    public void testMinimaxWinDiag() {
+        /*
+        x x
+        o o x
+        o
+
+        Check if computer knows how to win the game with win case
+        on a diagonal of the board
+         */
+        CellState[][] board = {{CellState.HUMAN, CellState.HUMAN, CellState.EMPTY},
+                {CellState.COMPUTER, CellState.COMPUTER, CellState.HUMAN},
+                {CellState.COMPUTER, CellState.EMPTY, CellState.EMPTY}};
+        ComputerPlayer obj = new ComputerPlayer(2);
+        int[] result = obj.getMove(new GameBoard(3, board), CellState.COMPUTER);
+        int row = result[1];
+        int col = result[2];
+        assertEquals("Bad Move X: " + row, 0, row);
+        assertEquals("Bad Move Y: " + col, 2, col);
+    }
+
+    @Test
+    public void testMinimaxDefRow() {
+        /*
+        x x.
+        x o
+        o o x
+
+        Check if computer knows how to defend to not lose the game
+        with opponent win case on a row of the board
+         */
+        CellState[][] board = {{CellState.HUMAN, CellState.HUMAN, CellState.EMPTY},
+                {CellState.HUMAN, CellState.COMPUTER, CellState.EMPTY},
+                {CellState.COMPUTER, CellState.COMPUTER, CellState.HUMAN}};
+        ComputerPlayer obj = new ComputerPlayer(2);
+        int[] result = obj.getMove(new GameBoard(3, board), CellState.COMPUTER);
+        int row = result[1];
+        int col = result[2];
+        assertEquals("Bad Move X: " + row, 0, row);
+        assertEquals("Bad Move Y: " + col, 2, col);
+    }
+
+    @Test
+    public void testMinimaxDefCol() {
+        /*
+        x o x
+        x x o
+            o
+
+        Check if computer knows how to defend to not lose the game
+        with opponent win case on a column of the board
+         */
+        CellState[][] board = {{CellState.HUMAN, CellState.COMPUTER, CellState.HUMAN},
+                {CellState.HUMAN, CellState.HUMAN, CellState.COMPUTER},
+                {CellState.EMPTY, CellState.EMPTY, CellState.COMPUTER}};
+        ComputerPlayer obj = new ComputerPlayer(2);
+        int[] result = obj.getMove(new GameBoard(3, board), CellState.COMPUTER);
+        int row = result[1];
+        int col = result[2];
+        assertEquals("Bad Move X: " + row, 2, row);
+        assertEquals("Bad Move Y: " + col, 0, col);
+    }
+
+    @Test
+    public void testMinimaxDefDiag() {
+        /*
+        x o x
+        x x o
+        o
+
+        Check if computer knows how to defend to not lose the game
+        with opponent win case on a diagonal of the board
+         */
+        CellState[][] board = {{CellState.HUMAN, CellState.COMPUTER, CellState.HUMAN},
+                {CellState.HUMAN, CellState.HUMAN, CellState.COMPUTER},
+                {CellState.COMPUTER, CellState.EMPTY, CellState.EMPTY}};
+        ComputerPlayer obj = new ComputerPlayer(2);
+        int[] result = obj.getMove(new GameBoard(3, board), CellState.COMPUTER);
+        int row = result[1];
+        int col = result[2];
+        assertEquals("Bad Move X: " + row, 2, row);
+        assertEquals("Bad Move Y: " + col, 2, col);
+    }
+}
diff --git a/src/test/java/org/eom/ttt_control/GameBoardTest.java b/src/test/java/org/eom/ttt_control/GameBoardTest.java
new file mode 100644
index 0000000..7f145b3
--- /dev/null
+++ b/src/test/java/org/eom/ttt_control/GameBoardTest.java
@@ -0,0 +1,92 @@
+package org.eom.ttt_control;
+
+import org.junit.Test;
+
+import static org.eom.ttt_control.CellState.*;
+import static org.junit.Assert.*;
+
+public class GameBoardTest {
+
+    @Test
+    public void testClone() {
+        CellState[][] board = {{EMPTY, EMPTY, EMPTY}, {EMPTY, EMPTY, EMPTY}, {EMPTY, EMPTY, EMPTY}};
+        GameBoard board1 = new GameBoard(3, board);
+        GameBoard board2 = board1.clone();
+        assertEquals(EMPTY, board1.getCell(1, 2));
+        assertEquals(EMPTY, board2.getCell(1, 2));
+
+        board1.setState(1, 2, COMPUTER);
+        assertEquals(EMPTY, board2.getCell(1, 2));
+    }
+
+    @Test
+    public void testSwitchPlayer() {
+        CellState player = HUMAN;
+        CellState otherPlayer = GameBoard.switchPlayer(player);
+        assertEquals(COMPUTER, otherPlayer);
+    }
+
+    @Test
+    public void testCheckWinHuman() {
+        /*
+        x x x
+          o
+        o
+
+        Check if check win method recognize the win situation
+        for human
+         */
+        CellState[][] board = {{HUMAN, HUMAN, HUMAN}, {EMPTY, COMPUTER, EMPTY}, {COMPUTER, EMPTY, EMPTY}};
+        GameBoard board1 = new GameBoard(3, board);
+        GameState state = board1.checkWin();
+        assertEquals(GameState.HUMAN_WIN, state);
+    }
+
+    @Test
+    public void testCheckWinComputer() {
+        /*
+        o o o
+          x
+        x
+
+        Check if check win method recognize the win situation
+        for computer
+         */
+        CellState[][] board = {{COMPUTER, COMPUTER, COMPUTER}, {EMPTY, HUMAN, EMPTY}, {HUMAN, EMPTY, EMPTY}};
+        GameBoard board1 = new GameBoard(3, board);
+        GameState state = board1.checkWin();
+        assertEquals(GameState.COMPUTER_WIN, state);
+    }
+
+    @Test
+    public void testCheckWinDraw() {
+        /*
+        x o x
+        o o x
+        x x o
+
+        Check if check win method recognize this draw situation
+         */
+        CellState[][] board = {{HUMAN, COMPUTER, HUMAN}, {COMPUTER, COMPUTER, HUMAN}, {HUMAN, HUMAN, COMPUTER}};
+        GameBoard board1 = new GameBoard(3, board);
+        GameState state = board1.checkWin();
+        assertEquals(GameState.DRAW, state);
+    }
+
+    @Test
+    public void testCheckWinPlaying() {
+        /*
+        x   x
+          o
+        o
+
+        Check if check win method recognize that the game is
+        still playing
+         */
+        CellState[][] board = {{HUMAN, EMPTY, HUMAN}, {EMPTY, COMPUTER, EMPTY}, {COMPUTER, EMPTY, EMPTY}};
+        GameBoard board1 = new GameBoard(3, board);
+        GameState state = board1.checkWin();
+        assertEquals(GameState.PLAYING, state);
+    }
+
+}
\ No newline at end of file
